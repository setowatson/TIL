# **補数（1の補数・2の補数）の詳しい解説**  

補数は **負の数を表現するための方法** で、特に **1の補数** と **2の補数** が使われる。  
2の補数表現は **コンピュータが負の数を扱う標準的な方法** 。

---

## **1. 1の補数（One’s Complement）**
**1の補数の作り方**  
- **ビットをすべて反転**（0を1に、1を0にする）
- 符号ビット（最上位ビット）も反転させる  

### **例：+25（8ビット）を1の補数にする**
まず、25 を **2進数（8ビット）** で表す。  
```
00011001（+25）
```
これを **1の補数** にする（ビット反転）。  
```
11100110（-25を表す）
```
---

### **1の補数の問題点**
1の補数では、0 の表現が `00000000`（+0）と `11111111`（-0） の **2通り** ある。  
これが計算の不具合を引き起こすため、2の補数が使われる。

---

## **2. 2の補数（Two’s Complement）**
**2の補数の作り方**  
1. **1の補数を求める**（ビット反転）  
2. **1を加算する**

### **例：+25（8ビット）を2の補数にする**
1の補数：
```
00011001（+25） → 11100110（1の補数）
```
2の補数（+1を加える）：
```
11100110  
+       1  
--------------
11100111（-25を表す）
```
**結果:** `11100111(2)` が -25 を表す。  

---

### **2の補数のメリット**
1. **0の表現が1通りしかない**
   - 1の補数は `00000000（+0）` と `11111111（-0）` があったが、2の補数では `00000000（+0）` だけ。  
2. **減算（引き算）が加算と同じ処理でできる**
   - 例： `A - B` を `A + (-B)` で計算可能  
   - ハードウェアの設計が簡単になる  

---

## **3. 2の補数を使った引き算の計算**
### **例：25 - 18 の計算**
1. 25（`00011001`）  
2. 18（`00010010`）の **2の補数を求める**  
   - 1の補数：`11101101`  
   - 2の補数（+1）：`11101110`（-18）  
3. `25 + (-18)` を計算  
```
  00011001（+25）
+ 11101110（-18）
-----------------
  00000111（7）
```
→ **7（正しい結果！）**

**引き算をせずに加算で計算できる** のが、2の補数の最大の利点！

---

## **4. 2の補数の範囲（8ビットの場合）**
| 表現 | 10進数の範囲 |
|------|-------------|
| 符号なし（Unsigned） | 0 ～ 255 |
| 符号あり（Signed, 2の補数） | -128 ～ 127 |

---

## **まとめ**
| 項目 | 1の補数 | 2の補数 |
|------|---------|---------|
| 作り方 | すべてのビットを反転 | 1の補数を求め、+1 する |
| 0 の表現 | `00000000（+0）` と `11111111（-0）` の2つ | `00000000（+0）` のみ |
| 計算のしやすさ | 減算は特別な処理が必要 | 減算を加算で処理できる |
| 使用用途 | ほぼ使われない | コンピュータの負の数表現の標準 |

コンピュータの負の数の計算には **2の補数が必須** 
