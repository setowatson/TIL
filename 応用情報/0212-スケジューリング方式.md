タスクを実行可能状態から実行状態にする(プロセッサの使用権を割り当てる)ことを「ディスパッチ」と言い、
<br>逆に実行状態から実行可能状態にすることを「プリエンプション」と言います。

![image](https://github.com/user-attachments/assets/960bf23b-9e01-4ee1-9383-103e86f56e07)


![image](https://github.com/user-attachments/assets/5dfa9f1e-ee08-4b0c-814c-ed281fc22bcb)

# スケジューリング手法の比較

| 方式 | 特徴 | メリット | デメリット |
|----------|----------|--------------|----------------|
| 到着順 | 先に到着したタスクを順番に処理 | シンプルで公平 | 長いタスクが先に来ると待ち時間が増加（コンボイ効果） |
| 優先度順| 事前に設定された優先度の高いタスクから処理 | 重要なタスクを優先できる | 優先度の低いタスクが永久に実行されない可能性（飢餓問題） |
| ★動的優先度順 | 実行中に優先度を変更しながら処理 | 飢餓問題を防ぎつつ重要なタスクを処理 | 優先度調整のコストが発生 |
| 処理時間順 | 処理時間(ターンアラウンドタイム)が短いタスクを優先 | 平均待ち時間を最小化できる | 処理時間が長いタスクが後回しになる（飢餓問題） |
| ★ラウンドロビン | 一定の時間（タイムクォンタム）ごとに順番に処理 | 公平でレスポンスタイムが安定 | タイムクォンタムの設定次第でオーバーヘッドが増加 |
| ★多重待ち行列 | タスクを複数のキュー（優先度・性質別）に分けて管理 | 柔軟にスケジューリングが可能 | 設定が複雑になりやすい |
| イベントドリブン | イベント（割り込み・IO完了など）に応じてタスクを実行 | 効率的にリソースを活用 | 実装が難しく、設計ミスで遅延が発生しやすい |

## どの方式を選ぶべきか？
- **公平性が重要** → ラウンドロビン  
- **優先度を考慮** → 優先度順 or 動的優先度  
- **高速なレスポンスを重視** → SJF or イベントドリブン  
- **リアルタイム処理** → 多重待ち行列 or 動的優先度  
- **シンプルな仕組みが必要** → 到着順 



## プリエンプティブ vs ノンプリエンプティブ

- プリエンプティブ
  - 実行中のタスクが **強制的に中断** され、他のタスクがCPUを使用できる。
  - 実行中に優先度の高いAに起動がかかると，Bを「実行可能状態」に戻してAを実行する。
  - **リアルタイム処理やマルチタスク環境** で有効。  
  - 例: ラウンドロビン、動的優先度順、多重待ち行列 など  

- ノンプリエンプティブ
  - **実行中のタスクが完了するまで** CPUの使用権を保持する。  
  - **オーバーヘッドが少なく、シンプルな処理** に向いている。  
  - 例: 到着順、処理時間順、静的優先度順 など  


